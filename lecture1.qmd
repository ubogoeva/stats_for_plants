---
title: "R и статистика в селекции: лекция 1"
author: "Елена Убогоева"
execute: 
  echo: true
format: 
  revealjs:
    slide-number: c/t
    # mainfont: Arial
    # fontsize: 14px
    theme: [default, custom.scss]
    # theme: [serif]
    # mouse-wheel: true
    auto-play-media: true
    width: 1280
    height: 720
css: styles.css
editor: visual
filters: [bg_style.lua]
---

## Информация о курсе

-   12 лекций в zoom по одной лекции в неделю: по средам в \~16.30 МСК.

-   Домашние задания (по желанию).

-   Будет запись каждой лекции, после занятия выложена на диск.

Структура курса:

-   5 лекций по работе в R

-   Статистические методы

## Почему важно изучать R в контексте статистики и селекции?

1.  Большинство статистических расчетов реализовано в R, следовательно можно воспользоваться готовым скриптом для своей задачи (с нужными преобразованиями).
2.  R предоставляет обширный функционал для быстрой и удобной работы с табличными данными (а наши данные являются табличными).
3.  Воспроизводимость результатов, что реализуется как выкладыванием кода, так и с помощью публикации результатов в системах `rmarkdown` и [Quarto](https://quarto.org/).
4.  R -- бесплатный и с открытым исходным кодом.

## Установка R и RStudio и начало работы

-   [Скачать](https://cran.r-project.org/bin/windows/base/) и установить свежую версию R с официального сайта (CRAN);

-   [Скачать](https://posit.co/download/rstudio-desktop/#download) и установить IDE RStudio;

-   Больше рекомендаций и решений возможных проблем при установке можно почитать [здесь](https://ubogoeva.github.io/how_to_install_R.html);

-   Advanced: [настройка](https://telegra.ph/R-how-to-organize-work-08-08) проектов и лайфхаки при работе в RStudio.

## Рекомендуемая литература

::: columns
::: {.column width="65%"}
Большая часть литературы по R на английском, однако начинают появляться в том числе материалы на русском.

-   [R4DataScience](https://r4ds.hadley.nz/) - книга для старта изучения R (Hadley Wickham).

-   [Advanced R](https://adv-r.hadley.nz/) - для продвинутых пользователей, которые хотят разобраться больше в устройстве языка (Hadley Wickham).

-   [Анализ данных и статистика в R](https://pozdniakov.github.io/tidy_stats/index.html) (автор Иван Поздняков).

-   [Введение в язык программирования R](https://textbook.rintro.ru/index.html) (автор Филипп Управителев)

-   Больше литературы [здесь](https://t.me/stats_for_science/25) и [здесь](https://t.me/r_in_action/61)
:::

::: {.column width="35%"}
![](https://r4ds.hadley.nz/cover.jpg){fig-align="right"}
:::
:::

## План лекции

-   Особенности архитектуры языка R.

-   Переменные.

-   Векторы:

    -   Типы векторов

    -   Индексация векторов

    -   Неявное и явное приведение типов

-   Логические операторы, булева алгебра

-   Работа с пропущенными значениями

## История языка R

::: {#.incremental .incremental}
-   R - язык программирования для статистической обработки данных и визуализации результатов (Википедия).

-   На самом деле R является языком широкого использования, например, с его помощью можно делать сайты, интерактивные приложения (shiny), презентации, писать книги и научные статьи.

-   R является наследником языка S, который был создан в отделе статистики AT&T в её исследовательском подразделении Bell Labs в 1976 году.

-   R был создан в 1991 в департаменте статистики Университета Окленда, Новая Зеландия. Разработчиками R поддерживается [CRAN](https://cran.r-project.org/) - репозиторий R-пакетов.

-   Для анализа данных есть набор пакетов `tidyverse`, главный разработчик Hadley Wickham.

-   Для работы с биологическими данными есть репозиторий [Bioconductor](https://www.bioconductor.org/).
:::

## Особенности архитектуры языка

R - высокоуровневый интерпретируемый мультипарадигменный язык программирования.

-   Парадигмы программирования:

    -   императивное (процедурное)

    -   функциональное

    -   объект-ориентированное

-   Типизация:

    -   динамическая - не нужно заранее определять тип переменной и тип может меняться в процессе скрипта

    -   нестрогая - происходит неявное приведение типов

Больше про историю языка можно посмотреть [здесь](https://www.youtube.com/watch?v=o1SI_RPa4jI).

## R как калькулятор

Любая книга по базовому R начинается с этого раздела, так что не будем нарушать традицию:

```{r}
40 + 2 # сложение
```

```{r}
20 - 2 # вычитание
```

```{r}
42 * 2 # умножение
```

```{r}
42 / 2 # деление
```

```{r}
2 ^ 4 # возведение в степень
```

## R как калькулятор

Функции для арифметических операторов: `sqrt()`, `log()`

::: incremental
-   Квадратный корень

    ```{r}
    sqrt(16) # квадратный корень, от слова square root
    ```

-   Логарифм

    ```{r}
    log(2) # по какому основанию логарифм?
    ```

-   По умолчанию натуральный логарифм, то есть основание `e`

    ```{r}
    log(exp(1)) # по умолчанию натуральный логарифм
    ```
:::

------------------------------------------------------------------------

Можно задать основание логарифма. Как это сделать, можно узнать, вызвав справку функции `?log`.

```{r}
log(x = 8, base = 2) # логарифм от числа 8 по основанию 2
log2(x = 8) # тоже логарифм от 8 по основанию 2
# есть также отдельная функция для десятичного логарифма
log10(1000)
```

::: {.callout-tip appearance="simple"}
Для вызова справки можно использовать `?<название функции>,` `help("<название функции>")` или нажать F1 на функции
:::

## Переменные

Поскольку R является в первую очередь императивным языком программирования, то переменные и оператор присваивания занимают центральную роль. В качестве оператора присваивания используется `<-`.

Можно набрать в RStudio, используя комбинацию клавиш `Alt -` (альт минус) или `Option -` на Mac.

Равно `=` тоже будет работать, но не рекомендуется к использованию.

Попробуем создать переменные:

```{r}
x <- 10
y <- x + 5
```

Почему ничего не появилось в консоли в качестве аутпута?

::: {.callout-note appearance="simple"}
Равно используется для подачи аргументов в функции: `log(x = 8, base = 2)`
:::

## Переменные

При создании переменной результат сохраняется и не выводится в консоль, если нам нужно узнать значение переменной, то можно использовать `print(x)` или просто набрать `x` в консоли.

```{r}
print(x)
x
y
```

Также можно посмотреть на переменные во вкладке environment в правом верхнем углу RStudio

## Переменные {style="font-size: 90%"}

С точки зрения компьютера в нем создается объект `10`, с которым связывается название переменной `x`. Переменные могут содержать все что угодно: числа, строки, датафреймы.

При создании переменных есть определенные правила:

-   В названии можно использовать латиницу (строчные и заглавные буквы), нижнее подчеркивание (`_`), точки, цифры;

-   нельзя использовать пробелы в названиях переменных;

-   нельзя использовать зарезервированные слова, например, `TRUE`, `FALSE`, `if`, `function`, с полным списком можно ознакомиться, вызвав `?Reserved`.

В R для разделения длинных имен рекомендуется использовать нижнее подчеркивание, например: `data_processed`. Главное - последовательность в стиле написания кода.

::: {.callout-tip appearance="simple"}
Подробнее про рекомендуемый стиль написания кода можно почитать [здесь](https://style.tidyverse.org/syntax.html)
:::

## Логические операторы

::: columns
::: {.column width="50%"}
Можно проверять на равенство переменные:

```{r}
x == y

y == 15
```

Не путаем операторы сравнения `==` и присваивания `=` (поэтому я использую `<-` как оператор присваивания).
:::

::: {.column width="50%"}
![](https://pozdniakov.github.io/tidy_stats/images/WaCM5x3mvQM.jpg)
:::
:::

## Логические операторы: проверка на неравенство

```{r}
logical1 <- x != y 
logical1 
logical2 <- x != 10 
logical2
```

Результаты выполнения логических операций мы можем сохранять в переменные для дальнейшего использования.

## Логические операторы: сравнение и отрицание

Можем сравнивать числа, используя знаки `>`, `<`, `>=`, `<=`.

```{r}
x > y 
x < y 
20 <= 20
```

Восклицательный знак означает логическое НЕ (отрицание):

```{r}
!TRUE 
!FALSE
```

## Логическое И и логическое ИЛИ

Логическое И: выдаст `TRUE`, если все значения `TRUE`

```{r}
logical1 & logical2
```

Логическое ИЛИ: будет `TRUE`, если хотя бы одно из значений `TRUE`

```{r}
logical1 | logical2
```

## Векторы

Векторы являются ключевым типом данных в R, на основе которых строятся более сложные структуры данных. Скаляры (одиночные значения) являются векторами длиной 1.

. . .

Вектор - набор данных **одного типа**. В R существует 4 основных часто использующихся типов векторов.

Основные типы векторов:

::: incremental
-   Логические, logical: `TRUE`, `FALSE`

-   Целочисленные, integer: `1L`, `190L`

-   Дробные, double или числа с плавающей точкой: `-1.5`, `0.05`, `5`. Еще есть `Inf`, `-Inf`, `NaN`.

-   Строковые, character: `'Hello world'`, `'character'`
:::

. . .

::: {.callout-note appearance="minimal"}
Целочисленные вектора сопровождаются знаком `L` и не содержат дробной части
:::

## Создание векторов {style="font-size: 90%"}

-   с помощью функции `c()`. Например: `x <- c(5, 4, 5, 3, 2)`.\
    `gene_names <- c('ARR1', 'ARF19', 'WOX5')`

-   с помощью двоеточия `:`, чтобы создавать набор чисел по порядку с шагом 1. Например:

    ```{r}
    16:30
    ```

-   с помощью `seq()`, если нужна последовательность чисел, с шагом, отличным от единицы

    ```{r}
    seq(from = 2, to = 20, by = 2)
    ```

-   с помощью `rep()` для создания повторяющихся элементов:

    ```{r}
    rep(c(1:3, 5), times = 3)
    ```

## Индексация векторов

В R индексация начинается с единицы (по-человечески). Для индексации используются квадратные скобки:

```{r}
sample_vector <- 11:20
sample_vector[1] # извлечь первый элемент вектора
```

Для извлечения нескольких элементов вектора в качестве индекса используется тоже вектор:

```{r}
sample_vector[2:5] # извлечь элементы со второго по пятый
sample_vector[c(3:6, 1, 10)] # извлечь элементы с третьего по шестой, первый и десятый
```

## Индексация векторов

Можно с помощью индексации заменять элементы:

```{r}
sample_vector[2] <- 0
sample_vector

```

::: callout-tip
Круглые скобки используются при работе с функциями, квадратные при индексации
:::

## Индексация векторов с помощью условия

Кроме индексации по номеру, можно извлечь элементы вектора, соответствующие какому-либо условию.

Например, извлечь все значения, которые больше или равны нулю вектора `x`

```{r}
x <- -3:3
x
```

Сначала используем условие:

```{r}
x >= 0
```

Получаем логический вектор, который можно использовать как индекс для отбора нужных элементов `x`

```{r}
x[x >= 0]
```

## Индексация векторов: проверка на четность {.smaller}

::: incremental
-   Допустим, у нас есть вектор `vect_for_even`

    ```{r}
    vect_for_even <- sample(1:100, 10)
    vect_for_even
    ```

    Задача вывести все четные элементы, используя знания об индексации векторов. Оператор остатка от деления: `%%`

-   Это решается без циклов. Сначала делаем проверку условия, что остаток от деления на два каждого элемента равен нулю:

    ```{r}
    vect_for_even %% 2 == 0
    ```

-   Далее используем полученный логический вектор в качестве индекса к исходному:

    ```{r}
    vect_for_even[vect_for_even %% 2 == 0]
    ```
:::

## Динамическая нестрогая типизация

::: columns
::: {.column width="50%"}
-   Динамическая: не нужно при создании вектора указывать его тип, как бывает в языках со статичной типизацией. Также тип вектора может поменяться в процессе кода:

    ```{r}
    vect <- seq(3, 11, 2)
    vect
    vect <- 'Hello world'
    ```

-   Нестрогая (слабая, weak): происходит неявное приведение типов
:::

::: {.column width="50%"}
![](images/image-1659150438.png){width="716"}
:::
:::

::: {.callout-note appearance="simple"}
R на этой картинке должен быть в левом нижнем углу
:::

## Неявное приведение типов

::: incremental
-   Векторы в R по определению могут быть только одного типа. Что произойдет, если мы попытаемся объединить в одном векторе элементы разных типов?

    Например так:

    ```{r}
    x <- c(10, TRUE, FALSE)
    ```

    Будет ли ошибка или каким-то образом произойдет объединение?

-   Ответ:

    ```{r}
    x
    ```

-   Произошло неявное приведение типов (*implicit coercion*): логический тип превратился в числа, `TRUE -> 1`, `FALSE -> 0`
:::

## Порядок неявного приведения типов

Логика порядка приведения типов: от менее общего к более общему

logical -\> integer -\> numeric -\> character

Часто происходит превращение числового вектора в строку.

Полезный пример неявного приведения типов: подсчет суммы истинных значений логического вектора

```{r}
sum(1:10 > 5)
set.seed(1)
p_val <- c(0.03, sample(seq(0.00001, 1, length.out = 100), 10))
p_val
sum(p_val < 0.05)
```

## Неявное приведение типов: иллюстрация

![](images/implicit_coercion_horizontal.png){width="545"}

```{r}
c(1, 2, 3, 4, 5, '6')
```

## Проверка типа вектора

Чтобы проверить тип вектора, можно использовать функцию `class()`:

```{r}
x <- c(1, 2, 3, 4, 5, '6')
class(x)
```

Также можно использовать функции проверки вектора на нужный тип: `is.numeric()`, `is.character()`, `is.logical()`

```{r}
is.numeric(x)
is.character(x)
```

::: {.callout-note appearance="simple"}
Чтобы ознакомиться со списком функций `is.*` можно набрать `is.` в консоли и нажать Tab
:::

## Явное приведение типов

Чтобы превратить вектор в нужный тип можно использовать функции: `as.numeric()`, `as.character()`, `as.logical()`

```{r}
x
as.numeric(x)
```

Создадим вектор, который содержит строки и превратим в numeric обратно

```{r}
char_vector <- c(1:6, 'seven')
char_vector
as.numeric(char_vector)
```

## Пропущенные значения

При работе с данными могут быть пропущенные значения в силу разных причин. В R обозначается `NA` - Not Available

```{r}
vector_missed <- c(1:10, NA)
vector_missed
```

Проблема пропущенных значений: неопределенность "заражает"

```{r}
sum(vector_missed)
mean(vector_missed)
```

Аргумент `na.rm` - способ вычислить среднее (сумму и тп) без учета пропущенных значений

```{r}
mean(vector_missed, na.rm = TRUE)
```

## Как находить пропущенные значения?

::: incremental
-   Давайте попробуем сравнить значения нашего вектора с `NA`

    ```{r}
    vector_missed == NA
    ```

-   Ой\
    Почему в сравнении `NA == NA` получается `NA`?

    ```{r}
    NA == NA
    ```

-   Пропущенное значение - это отсутствие информации о чем-либо, следовательно, мы не можем сделать вывод, является ли отсутствие информации равным другому отсутствию.
:::

## Для выявления пропущенных значений используем функцию `is.na()`

```{r}
is.na(vector_missed)
```

Теперь с помощью логического отрицания (NOT, !) этого вектора можно отобрать не-пропущенные элементы:

```{r}
!is.na(vector_missed)
vector_missed[!is.na(vector_missed)]
```

После этого можно делать интересующие операции над этим вектором, уже не беспокоясь о пропущенных значениях.

## Чек-лист, что нужно знать после лекции

-   Что такое переменные, как их создавать

-   Как проверять переменные на равенство/неравенство, больше/меньше

-   Правила индексации векторов

-   Неявное приведение типов

-   Работа с пропущенными значениями

## Вопросы?

::: columns
::: {.column width="50%"}
Подписывайтесь на телеграм-канал о статистике:

![](images/image-650896138.png){width="440"}
:::
:::
